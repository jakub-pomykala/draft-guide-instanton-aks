//
// Copyright (c) 2023 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: instanton-aks
:page-layout: guide-multipane
:page-duration: 45 minutes
:page-releasedate: 2023-08-31
:page-description: Learn how to accelerate the startup of your containers using Open Liberty InstantOn and improve the CPU and memory usage using Semeru Cloud Compiler on Azure Kubernetes Services (AKS).
:page-tags: ['Kubernetes', 'Podman', 'Cloud']
:page-permalink: /guides/{projectid}
:page-related-guides: ['kubernetes-intro', `openliberty-operator-intro`, 'cloud-azure']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:page-seo-title: Faster startup and better CPU and memory use in containers on Azure
:page-seo-description: A getting started tutorial with examples on how to containerize a Java microservice with Open Liberty InstantOn feature to accelerate the startup time. To improve the CPU and memory usage, deploy your application by enabling Semeru Cloud Compiler (SCC) in your deploying to Azure Kubernetes Services (AKS) on Microsoft Azure. by using Azure Container Registry as a private container registry.
:guide-author: Open Liberty
= Faster startup and better CPU and memory use in containers on Azure

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website^].

Explore how to accelerate the startup of your containers by using Open Liberty InstantOn and improve the CPU and memory usage by enabling Semeru Cloud Compiler in your deployment to Azure Kubernetes Servivces (AKS) on Microsoft Azure. 



// =================================================================================================
// Introduction
// =================================================================================================

== What you'll learn

InstantOn, a new feature within Open Liberty, enables you to take full advantage of cloud infrastructure with fast and dynamic start-up—without inheriting compromises commonly found when compiling your code to native images. InstantOn will allow you to easily adopt serverless practices while enabling you to respond faster to ever-changing workload demands, improve sustainability and reduce costs by dynamically adjusting infrastructure to demand and facilitate innovation through modern application architectures and serverless. 

By using Semeru Cloud Compiler you'll be able to do just-in-time code compiling as a process independent of the applications virtual machine. Its benefits include CPU and memory utilization optimization in the application VM and improved resiliency.

You will learn how to containize a microservice with Open Liberty InstantOn and deploy the container with Semeru Cloud Compiler enablement to a Kubernetes cluster on Azure Kubernetes Servivces (AKS).

https://openliberty.io/docs/latest/instanton.html[Open Liberty InstantOn^] provides fast startup times for MicroProfile and Jakarta EE applications. Your applications can start in milliseconds, without compromising on throughput, memory, development-production parity, or Java language features.

Semeru Cloud Compiler uses the https://eclipse.dev/openj9/docs/jitserver[JITServer^] (Just-in-Time Server) technology that is included in the https://www.eclipse.org/openj9/[Eclipse OpenJ9 JVM^]. It decouples the JIT compiler from the JVM to prevent your Java application from suffering possible negative effects due to CPU and memory consumption caused by JIT compilation in the JVM.

image::checkpoint_diagram.png[Deployment,align="center"]

Microsoft Azure offers a managed Kubernetes service called Azure Kubernetes Services (AKS). AKS simplifies the process of running Kubernetes on Azure without needing to install or maintain your Kubernetes control plane. It provides a hosted kubernetes cluster where you can deploy your microservices. You will use AKS with Azure Container Registry. Azure Container Registry is a private registry that is used to store and distribute your container images. Note, Azure Container Registry is a paid service but there is a option for a free trial which you can setup by visting https://azure.microsoft.com/en-gb/free[Try Azure for free^] and following the instructions. 


The microservice you will deploy is called `system`. The `system` microservice returns the JVM system properties of the running container. It also returns the pod’s name in the HTTP header, making replicas easy to distinguish from each other.

image::checkpoint_diagram.png[Deployment,align="center"]

// =================================================================================================
// Prerequisites
// =================================================================================================

== Additional prerequisites

You must run this guide in a Linux environment with the X86-64/AMD64 processor and the following version:

* *Ubuntu:* kernel version must be 5.9 or greater
* *RHEL:*   version must be 9.0 or greater

Before you begin, the following additional tools need to be installed on your Linux:

* *Podman:* You need containerization software for building containers. Kubernetes supports various container types, but you will need the latest available version of Podman in this guide. For installation instructions, refer to the official https://podman.io/docs/installation documentation.

* *kubectl:* You need the Kubernetes command-line tool `kubectl` to interact with your Kubernetes cluster. See the official https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl[Install and Set Up kubectl^] documentation for information about downloading and setting up `kubectl` on your platform.

* *libseccomp-dev:* You need ot intall `libseccomp-dev` to enable the instalation of `runc`. `libseccomp` is required to enable seccomp support.

+
You can install it using the following command:

+
[role=command]
```
sudo apt-get install libseccomp-dev
```

* *runc:* Runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. Find out more information and installation instructions: https://github.com/opencontainers/runc[opencontainers/runc Github repository^]

* *Azure Subscription:* To run this guide, you will need an Azure subscription. Navigate to the 
https://azure.microsoft.com/en-us/pricing/purchase-options/pay-as-you-go/[Microsoft Azure Purchase Options^] 
to create an account with your email and start a Pay-As-You-Go subscription. 

* *Azure CLI:* You will need to use the Azure Command Line Interface (CLI). See the official
https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest[Install the Azure CLI^]
documentation for information about setting up the Azure CLI for your platform. 
To verify that the Azure CLI is installed correctly, run the following command:

+
[role=command]
```
az --version
```

* *kubectl:* You need the Kubernetes command-line tool `kubectl` to interact with your Kubernetes cluster.
If you do not have `kubectl` installed already, use the Azure CLI to download and install `kubectl` with the following command:

+
[role=command]
```
az aks install-cli
```

To begin this guide, make sure that you are logged in to Azure to get access to your subscription:

[role=command]
```
az login
```

// =================================================================================================
// Getting Started
// =================================================================================================

[role=command]
include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide because it would be too long due to all setup the user will have to do.

=== Creating a resource group


A resource group is an Azure construct to manage a logical collection of resources for your cloud deployments on Azure. 
You must create a new resource group to manage the resources you need for your Kubernetes deployment.

To create a resource group, an Azure location must be specified. The metadata for your resources are stored at this specified Azure location. 
If resources are created later without specifying a location, these new resources run in the
same region that you specified for creating a resource group. 

See the list of available Azure regions for your Azure subscription:

[role=command]
```
az account list-locations -o table
```

You will see an output similar to the following:

[role="no_copy"]
----
DisplayName          Latitude    Longitude    Name
-------------------  ----------  -----------  ------------------
Central US           41.5908     -93.6208     centralus
East US              37.3719     -79.8164     eastus
East US 2            36.6681     -78.3889     eastus2
West US              37.783      -122.417     westus
North Central US     41.8819     -87.6278     northcentralus
South Central US     29.4167     -98.5        southcentralus
Canada Central       43.653      -79.383      canadacentral
Canada East          46.817      -71.217      canadaeast
UK South             50.941      -0.799       uksouth
UK West              53.427      -3.084       ukwest
West Central US      40.890      -110.234     westcentralus
West US 2            47.233      -119.852     westus2
----

The `name` column specifies the region name that you use to create your resource group.

However, AKS is not available in all regions. Make sure that the region you select is 
https://azure.microsoft.com/en-us/global-infrastructure/services/?products=kubernetes-service[compatible with AKS^].

Create a resource group using the `az group create` command. Remember to replace `[location]` with a region 
that is available for your subscription and compatible with AKS.

[role=command]
```
az group create -l [location] -n guideGroup
```

You will see an output similar to the following:

[role="no_copy"]
```
{
  "id": "/subscriptions/[subscription-id]/resourceGroups/guideGroup",
  "location": "[location]",
  "managedBy": null,
  "name": "guideGroup",
  "properties": {
    "provisioningState": "Succeeded"
  },
  "tags": null,
  "type": null
}
```

=== Creating a container registry

Your private container registry manages Docker images that you build in later steps. 
With the Azure `az acr` command, create an Azure Container Registry.
Replace `[registry-name]` with a container registry name that is unique within Azure and
contains 5-50 alphanumeric characters. You can check whether a registry name already exists by
using the `az acr check-name -n [registry-name]` command.

[role=command]
```
az acr create -g guideGroup -n [registry-name] --sku Basic --admin-enabled
```

In the `az acr create` command, the `-g` option specifies the resource group to designate to the container registry. 
You created this resource group before as `guideGroup`. The `-n` option specifies the name of the
container registry to be created, which is defined as `[registry-name]`. The `--admin-enabled` flag indicates that the admin user is enabled. 

The possible Stock Keeping Unit (SKU) values that can be passed into the `--sku` option are `Basic`, `Standard`, and `Premium`.
These different SKU options provide pricing for various levels of capacity and usage. You use a Basic SKU because it is cheaper 
and the services you deploy have low storage and throughput requirements.

You will see an output similar to the following:

[role="no_copy"]
```
{
  "adminUserEnabled": true,
  "creationDate": "2019-06-05T20:28:09.637994+00:00",
  "id": "/subscriptions/[subscription-id]/resourceGroups/guideGroup/providers/Microsoft.ContainerRegistry/registries/[registry-name]",
  "location": "[location]",
  "loginServer": "[registry-name].azurecr.io",
  "name": "[registry-name]",
  "networkRuleSet": null,
  "provisioningState": "Succeeded",
  "resourceGroup": "guideGroup",
  "sku": {
    "name": "Basic",
    "tier": "Basic"
  },
  "status": null,
  "storageAccount": null,
  "tags": {},
  "type": "Microsoft.ContainerRegistry/registries"
}
```
In the output, the value for `loginServer` is the server name for your container registry,
which is `[registry-name].azurecr.io`, with all lowercase letters.

=== Logging into the container registry

To push Podman images to your registry, you must log in to your Azure Container Registry by using the Azure CLI.

To login to the registry with Podman instead of Podman there is a few more commands required.

Firstly, login to the regsitry whilst exposing the token which you will set to the `TOKEN` variable

[role=command]
```
TOKEN=$(az acr login --name [registry-name] --expose-token --output tsv --query accessToken)
```

Next, log podman into the registry server by passing through the token variable you have set in the previous step.

[role=command]
```
podman login [registry-name.azurecr.io] --username 00000000-0000-0000-0000-000000000000 --password-stdin <<< $TOKEN
```

Once you log in, you will see the following message:

[role="no_copy"]
----
Login Succeeded
----

// =================================================================================================
// Building your InstantOn image
// =================================================================================================

== Building your InstantOn image 

To speed up your container startup time, build your container image with the Open Liberty InstantOn.

This configuration performs the application process checkpoint and stores the process data as the last layer of the application container image. In this guide, use the `afterAppStart` checkpoint option.
This phase has the potential to provide the fastest startup time when restoring the application instance. The checkpoint happens after all configured applications are reported as started.
This phase happens before opening any ports for listening to incoming requests for the applications. For more information about the checkpoint options, see the link:https://openliberty.io/docs/latest/instanton.html#beforeAppStart[Faster startup with InstantOn^]

Navigate to the `start` directory. Run the following command to build and package the `system` microservice to a war file:

[role=command]
```
mvn package
```

To containize your microservice, use the `kernel-slim-java17-openj9-ubi` Liberty container image that uses the Open Liberty basic runtime with the Semeru Runtime 17.
 
[role="code_command hotspot file=0",subs="quotes"]
----
#Create the `system/Containerfile`.#
`system/Containerfile`
----

// File 0
system/Containerfile
[source, text, linenums, role="code_column"]
----
include::finish/system/Containerfile[]
----

[role="code_command hotspot file=1",subs="quotes"]
----
#Create the `inventory/Containerfile`.#
`inventory/Containerfile`
----

// File 1
inventory/Containerfile
[source, text, linenums, role="code_column"]
----
include::finish/inventory/Containerfile[]
----

Starting from the [hotspot=kernel-slim file=0]`kernel-slim-java17-openj9-ubi` Liberty container image, build the container image by copying the local [hotspot=config file=0]`config` directory to the container `config` directory, running the [hotspot=features file=0]`features.sh` script to add the Liberty features that your microservice is required to operate, copying your microservice [hotspot=war file=0]`war` file, and running the [hotspot=configure file=0]`configure.sh` script to get a pre-warmed container image.

Finally, run the [hotspot=checkpoint file=0]`checkpoint.sh` script to make a checkpoint. The execution of the `checkpoint.sh` must be the last instruction during your container image build. This configuration performs the application process checkpoint and stores the process data as the last layer of the application container image. In this guide, use the `afterAppStart` checkpoint option. For more information about the checkpoint options, see the https://openliberty.io/docs/latest/instanton.html#beforeAppStart[Faster startup with InstantOn^] documentation.

Use the following command to build the system InstantOn container image. To grant the necessary Linux capabilities to the container image build, this command must be run either as the `root` user or by using the `sudo` utility.

[role=command]
----
podman build \
   -t dev.local/system:1.0-SNAPSHOT \
   --cap-add=CHECKPOINT_RESTORE \
   --cap-add=SYS_PTRACE \
   --cap-add=SETPCAP \
   --security-opt seccomp=unconfined \
   system/.
----

Next use the following command to build the inventory InstantOn container image.

[role=command]
----
podman build \
   -t dev.local/system:1.0-SNAPSHOT \
   --cap-add=CHECKPOINT_RESTORE \
   --cap-add=SYS_PTRACE \
   --cap-add=SETPCAP \
   --security-opt seccomp=unconfined \
   inventory/.
----

The three `--cap-add` options grant the three Linux capabilities that CRIU requires to perform the application process checkpoint during the container image build. The `--security-opt` option grants access to all Linux system calls to the container image build.


For more information to build the InstantOn image by Podman, see the https://openliberty.io/docs/latest/instanton.html#three_step_process[Building the InstantOn image by using the three-step process with Docker or Podman^] documentation.

To verify that the image is built, run the following command to list all local container images:

[role=command]
```
podman images
```

Verify that the both `inventory` and `system` images are listed amongst them, for example:

[source, role="no_copy"]
----
REPOSITORY                        TAG
dev.local/system                  1.0-SNAPSHOT
dev.local/inventory               1.0-SNAPSHOT
icr.io/appcafe/open-liberty       kernel-slim-java17-openj9-ubi       
----

If you don't see the `system:1.0-SNAPSHOT` image, then check the Maven build log for any potential errors.

Now, you can run your `system` InstantOn container image locally using the following command:

[role=command]
----
podman run \
  --rm \
  --cap-add=CHECKPOINT_RESTORE \
  --cap-add=SETPCAP \
  --security-opt seccomp=unconfined \
  -p 9080:9080 \
  system:1.0-SNAPSHOT
----

Next, open a new terminal window and use the following command to run your `inventory` InstantOn container image locally:

[role=command]
----
podman run \
  --rm \
  --cap-add=CHECKPOINT_RESTORE \
  --cap-add=SETPCAP \
  --security-opt seccomp=unconfined \
  -p 9080:9080 \
  inventory:1.0-SNAPSHOT
----

The `--cap-add` option grants the `CHECKPOINT_RESTORE` and `SETPCAP` capabilities. The `SYS_PTRACE` capability is not required to run the InstantOn container image.

After you see the following message, your application server is ready:

[source, role="no_copy"]
----
[AUDIT   ] CWWKF0011I: The defaultServer server is ready to run a smarter planet. The defaultServer server started in 0.298 seconds.
----

Notice that the startup time is less than 1 second. Point your browser to the http://localhost:9080/system/properties URL. You see a result in JSON format with the system properties of your container JVM. After you finish checking out the application, stop the Open Liberty server by pressing `CTRL+C` in the command-line session where you ran the container.

If you'd like like to compare startup times with and withot InstantOn you can do so by following the instructions provided in link:https://openliberty.io/blog/2023/06/29/rapid-startup-instanton.html[How to package your cloud-native Java application for rapid startup^].

// =================================================================================================
// Creating a Kubernetes cluster on AKS
// =================================================================================================

== Creating a Kubernetes cluster on AKS

Before you can deploy your microservice, you must create a Kubernetes cluster.

// =================================================================================================
// Provisiong a cluster
// =================================================================================================

=== Provisioning a cluster

To create your AKS cluster, use the `az aks create` cluster command. 
When the cluster is created, the command outputs information about the cluster.
You might need to wait while your cluster is being created.

[role=command]
```
az aks create -g guideGroup -n guideCluster
```

Running this command creates an AKS cluster that is called `guideCluster` with the resource group
`guideGroup`.

The option `--node-count -c` can also be added to this `az aks create` command to create a cluster
with a certain number of nodes in the Kubernetes node pool. By default, if this option is excluded,
three nodes are assigned to the node pool.

An AKS cluster requires a service principal, which is an identity that is used to represent a resource in Azure that 
can be assigned roles and permissions to interact with other resources and the Azure API. The `az aks create` command automatically generates 
a service principal to use with your newly created cluster. 
Optionally, you can https://docs.microsoft.com/en-us/azure/aks/kubernetes-service-principal#manually-create-a-service-principal[manually create a service principal^] yourself and create a cluster with this new service principal.
However, to run this command, your Azure account must have permission access to create service principals. 

Merge the credentials of your cluster into your current Kubernetes configuration by using the `az aks get-credentials` command. 
The default Kubernetes configuration file that is updated with your cluster credentials is located within the `~/.kube/config` filepath. 

[role=command]
```
az aks get-credentials -g guideGroup -n guideCluster
```

You will see an output similar to the following:

[role="no_copy"]
----
Merged "guideCluster" as current context in /Users/.kube/config
----

Run the following command to check the status of the available nodes in your AKS cluster:

[role=command]
```
kubectl get nodes
```

The `kubectl get nodes` command outputs information about three nodes, as the cluster was created with the default number of nodes in a node pool.
The `STATUS` of each node is in the `Ready` state. 

[role="no_copy"]
----
NAME                       STATUS   ROLES   AGE     VERSION
aks-nodepool1-21407934-0   Ready    agent   2m25s   v1.12.8
aks-nodepool1-21407934-1   Ready    agent   2m48s   v1.12.8
aks-nodepool1-21407934-2   Ready    agent   2m34s   v1.12.8
----

// =================================================================================================
// Storing registry credentials in a secret
// =================================================================================================

=== Storing registry credentials in a secret

To be able to pull the images from your Azure container registry, the credentials of your registry must be added to your service
through a secret. 

View the password for your Azure container registry:

[role=command]
```
az acr credential show -n [registry-name] --query "passwords[0].value" -o tsv
```

Use the `kubectl create secret podman-registry` command to create a secret to hold your registry credentials. 
Replace `[password]` with the registry password that you viewed with the 
`az acr credential show -n [registry-name]` command. The email that is associated with your Podman account replaces `[email-address]`.

[role=command]
```
kubectl create secret docker-registry guidesecret \
    --docker-server=[registry-server] \
    --docker-username=[registry-name] \
    --docker-password=[password] \
    --docker-email=[email-address]
```
The secret is successfully created with the following output:

[role="no_copy"]
----
secret/guidesecret created
----

// =================================================================================================
// Uploading images to a container registry
// =================================================================================================

== Uploading images to a container registry

// =================================================================================================
// Pushing the images to a container registry
// =================================================================================================

=== Pushing the images to a container registry

Pushing the images to a registry allows the cluster to create pods using your container images.

First, tag your container images with your registry.
Replace `[registry-server]` with the server name of your container registry.
To get the server for your registry, run the `az acr show -n [registry-name] --query loginServer` command.
The `[registry-server]` looks like `[registry-name].azurecr.io`.

[role=command]
```
podman tag system:1.0-SNAPSHOT [registry-server]/system:1.0-SNAPSHOT
podman tag inventory:1.0-SNAPSHOT [registry-server]/inventory:1.0-SNAPSHOT
```

Finally, push your images to the registry:

[role=command]
```
podman push [registry-server]/system:1.0-SNAPSHOT
podman push [registry-server]/inventory:1.0-SNAPSHOT
```

// =================================================================================================
// Installing the Operator
// =================================================================================================

== Installing the Operator

// Static guide instruction
ifndef::cloud-hosted[]
Before you can deploy your microservice, you must install the https://cert-manager.io[cert-manager^] and the Open Liberty Operator. For more information, see the link:https://github.com/OpenLiberty/open-liberty-operator/tree/main/deploy/releases/1.2.1#readme[installation instructions].

First, install the cert-manager to your Kubernetes cluster by running the following command:
[role='command']
```
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.12.1/cert-manager.yaml
```


Next, install Custom Resource Definitions (CRDs) for the Open Liberty Operator by running the following command:
[role='command']
```
kubectl apply --server-side -f https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/1.2.1/kubectl/openliberty-app-crd.yaml
```
Custom Resources extend the Kubernetes API and enhance its functionality.

Set environment variables for namespaces for the Operator by running the following commands:

[role='command']
```
OPERATOR_NAMESPACE=default
WATCH_NAMESPACE='""'
```

Next, run the following commands to install cluster-level role-based access:

[role='command']
```
curl -L https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/1.2.1/kubectl/openliberty-app-rbac-watch-all.yaml \
  | sed -e "s/OPEN_LIBERTY_OPERATOR_NAMESPACE/${OPERATOR_NAMESPACE}/" \
  | kubectl apply -f -
```

Finally, run the following commands to install the Operator:

[role='command']
```
curl -L https://raw.githubusercontent.com/OpenLiberty/open-liberty-operator/main/deploy/releases/1.2.1/kubectl/openliberty-app-operator.yaml \
  | sed -e "s/OPEN_LIBERTY_WATCH_NAMESPACE/${WATCH_NAMESPACE}/" \
  | kubectl apply -n ${OPERATOR_NAMESPACE} -f -
```
endif::[]

// Cloud hosted guide instruction
ifdef::cloud-hosted[]
The Open Liberty Operator is already installed in this Skills Network environment. To learn how to install the Open Liberty Operator yourself, see the link:https://openliberty.io/guides/cloud-openshift-operator.html#installing-the-operators[Deploying microservices to OpenShift by using Kubernetes Operators^] guide or the link:https://github.com/OpenLiberty/open-liberty-operator/blob/main/doc/user-guide-v1.adoc#operator-installation[Open Liberty Operator documentation^].
endif::[]

To check that the Open Liberty Operator has been installed successfully, run the following command to view all the supported API resources that are available through the Open Liberty Operator:
[role='command']
```
kubectl api-resources --api-group=apps.openliberty.io
```

Look for the following output, which shows the https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/[custom resource definitions^] (CRDs) that can be used by the Open Liberty Operator:

[role='no_copy']
```
NAME                      SHORTNAMES         APIGROUP              NAMESPACED   KIND
openlibertyapplications   olapp,olapps       apps.openliberty.io   true         OpenLibertyApplication
openlibertydumps          oldump,oldumps     apps.openliberty.io   true         OpenLibertyDump
openlibertytraces         oltrace,oltraces   apps.openliberty.io   true         OpenLibertyTrace
```

Each CRD defines a kind of object that can be used, which is specified in the previous example by the `KIND` value. The `SHORTNAME` value specifies alternative names that you can substitute in the configuration to refer to an object kind. For example, you can refer to the `OpenLibertyApplication` object kind by one of its specified shortnames, such as `olapps`. 

The `openlibertyapplications` CRD defines a set of configurations for deploying an Open Liberty-based application, including the application image, number of instances, and storage settings. The Open Liberty Operator watches for changes to instances of the `OpenLibertyApplication` object kind and creates Kubernetes resources that are based on the configuration that is defined in the CRD.

// =================================================================================================
// Deploying microservices to AKS
// =================================================================================================

== Deploying microservices to AKS

// =================================================================================================
// Creating a deployment definition
// =================================================================================================

=== Creating a deployment definition

Now that your container images are built and you have created a Kubernetes cluster, you can deploy the images using a Kubernetes resource definition.

A Kubernetes resource definition is a `yaml` file that contains a description of all your 
deployments, services, or any other resources that you want to deploy. All resources can 
also be deleted from the cluster by using the same `yaml` file that you used to deploy them.
The [hotspot]`kubernetes.yaml` resource definition file is provided for you. If you are interested 
in learning more about the Kubernetes resource definition, check out the 
https://openliberty.io/guides/kubernetes-intro.html[Deploying microservices to Kubernetes^]
guide.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `kubernetes.yaml`.#
`kubernetes.yaml`
----
[role="edit_command_text"]
Replace [hotspot=sysImage hotspot=invImage file=0]`[registry-server]` with your container registry server.
You can get the login server for your registry by running the `az acr show -n [registry-name] --query loginServer` command.

kubernetes.yaml
[source, yaml, linenums, indent=0, role="code_column hide_tags=createKNativeSys,createKNativeInv,semeruCloudCompilerSys,semeruCloudCompilerInv,env"]
----
include::finish/kubernetes.yaml[]
----

The [hotspot=sysImage hotspot=invImage file=0]`image` is the name and tag of the container image that you want 
to use for the container. The [hotspot]`kubernetes.yaml` file references the images that you pushed to your registry
for the [hotspot=sysImage file=0]`system` and [hotspot=invImage file=0]`inventory` repositories. These images can be pulled with the [hotspot=sysSecret hotspot=invSecret file=0]`secret` that you created before.

The service that is used to expose your deployments has a type of [hotspot=sysLoadBalancer hotspot=invLoadBalancer file=0]`LoadBalancer`. 
This means you can access these services from IP addresses that forward incoming traffic to your nodepool via a specific port.
You can expose your services in other ways such as using a `NodePort` service type. 

// =================================================================================================
// Deploying your application
// =================================================================================================

=== Deploying your InstantOn application

You can configure the specifics of the Open Liberty Operator-controlled deployment with a YAML configuration file.

The [hotspot file=0]`kubernetes.yaml` file is configured to deploy two of resources of the [hotspot=olappSys hotspot=olappInv file=0]`OpenLibertyApplication` kind, [hotspot=system file=0]`system` and [hotspot=inventory file=0]`inventory`, which are controlled by the Open Liberty Operator.

The [hotspot=sysImage file=0]`applicationImage` for the `system` service and the [hotspot=sysImage file=0]`applicationImage` for the `inventory` service parameter defines what container image is deployed as part of the `OpenLibertyApplication` CRD.

In [hotspot=securityContext file=0]`securityContext` configuration, the [hotspot=runAsNonRoot file=0]`runAsNonRoot` cofiguration specifies that for any configuration in the pod, all processes run with a non-root user ID. With the [hotspot=capabilities file=0]`capabailities` configuration, we are only adding the the  `CHECKPOINT_RESTORE` and `SETCAP` capabilities for our InstantOn image and dropping all the remaining capabilities by specifying [hotspot=ALL file=0]`ALL` in the `capabilities.drop`. 

Run the following command to deploy the `system` and `inventory` InstantOn images to your AKS:
[role=command]
```
kubectl apply -f kubernetes.yaml
```

When the images are deployed, run the following command to check the status of your pods:

[role=command]
```
kubectl get pods
```

If all the pods are healthy and running, you see an output similar to the following:
[source, role="no_copy"]
----
NAME                                        READY   STATUS    RESTARTS   AGE
inventory-84fc67d49c-z98z4               1/1     Running   0             35s
olo-controller-manager-b99549758-8bcfh   1/1     Running   0             15m
system-6ff57df9-4zp2p                    1/1     Running   0             35s
----

=== Making requests to the microservices

You need the external IP addresses that are associated with the `system` and `inventory` services to try out your microservices.

Take note of the `EXTERNAL-IP` in the output of the following commands. It is the 
hostname that you will later substitute into `[EXTERNAL-IP]` to access the `system` and `inventory` services.

View the information of the `system` service to see its `EXTERNAL-IP` address:

[role='command']
```
kubectl get svc/system
```

You need to wait a while for the `EXTERNAL-IP` to change from `<pending>` to an IP address.

[role="no_copy"]
----
NAME                TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)           AGE
system              LoadBalancer   10.0.219.9     <pending>       9080:30206/TCP    26s
----

[role="no_copy"]
----
NAME                TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)           AGE
system              LoadBalancer   10.0.219.9     20.26.64.170    9080:30206/TCP    74s
----

View the information of the `inventory` service to see its `EXTERNAL-IP` address:

[role='command']
```
kubectl get svc/inventory
```

You will need to wait a while for the `EXTERNAL-IP` to change from `<pending>` to an IP address.

[role="no_copy"]
----
NAME                TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)           AGE
inventory           LoadBalancer   10.0.175.197   <pending>       9081:32363/TCP    69s
----

[role="no_copy"]
----
NAME                TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)           AGE
inventory           LoadBalancer   10.0.175.197   20.26.64.162  9081:32363/TCP      2m8s
----

To access your microservices, point your browser to the following URLs, substituting the appropriate `EXTERNAL-IP` hostnames
for the `system` and `inventory` services:

* `{system-api}`
* `{inventory-api}`

In the first URL, you see a result in JSON format with the system properties of the container JVM.
The second URL returns an empty list, which is expected because no system properties are stored in the inventory yet. 

Point your browser to the `{inventory-api}/[system-EXTERNAL-IP]` URL. When you visit this URL, these system
properties are automatically stored in the inventory. Go back to `{inventory-api}` and
you see a new entry for `[system-EXTERNAL-IP]`.

=== Enabling Semeru Cloud Compiler

Semeru Cloud Comiler server instance provides real-time code compiling as a process, independent of the application.

By setting the [hotspot=enable file=0]`enable` parameter to `true` the [hotspot=semeruCloudCompilerSys file=0]`semeruCloudCompiler` configuration is granted the application access to the Semeru Cloud Compiler server instance.

To configure the Semeru Cloud Compiler to handle Just-In-time (JIT) compilation requests from the application you have to set it's [hotspot=enable file=0]`enable` parameter to `true` and also specify the amount of replices you would like.
You are not required to specify the amount of replices as the default is `1`. Another parameter that you can specify is the `resource`; this is the resource requests and limits for the Semeru Cloud Compiler. The CPU deafults to `100m` with a limit of `2000m`.
The memory defaults to `800Mi`, with a limit of `1200Mi`. To find out more you can visit link:https://github.com/OpenLiberty/open-liberty-operator/blob/main/doc/user-guide-v1.adoc[Open Liberty Operator v1.2.0+ documentation].

