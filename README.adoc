//
// Copyright (c) 2023 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: instanton-aks
:page-layout: guide-multipane
:page-duration: 45 minutes
:page-releasedate: 2023-08-31
:page-description: Learn how to accelerate the startup of your containers using Open Liberty InstantOn and improve the CPU and memory usage using Semeru Cloud Compiler on Azure Kubernetes Services (AKS).
:page-tags: ['Kubernetes', 'Podman', 'Cloud']
:page-permalink: /guides/{projectid}
:page-related-guides: ['kubernetes-intro', `openliberty-operator-intro`, 'cloud-azure']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:page-seo-title: Faster startup and better CPU and memory use in containers on Azure
:page-seo-description: A getting started tutorial with examples on how to containerize a Java microservice with Open Liberty InstantOn feature to accelerate the startup time. To improve the CPU and memory usage, deploy your application by enabling Semeru Cloud Compiler (SCC) in your deploying to Azure Kubernetes Services (AKS) on Microsoft Azure. by using Azure Container Registry as a private container registry.
:guide-author: Open Liberty
= Faster startup and better CPU and memory use in containers on Azure

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website^].

Explore how to accelerate the startup of your containers by using Open Liberty InstantOn and improve the CPU and memory usage by enabling Semeru Cloud Compiler in your deployment to Azure Kubernetes Servivces (AKS) on Microsoft Azure. 



// =================================================================================================
// Introduction
// =================================================================================================

== What you'll learn

InstantOn, a new feature within Open Liberty, enables you to take full advantage of cloud infrastructure with fast and dynamic start-up—without inheriting compromises commonly found when compiling your code to native images. InstantOn will allow you to easily adopt serverless practices while enabling you to respond faster to ever-changing workload demands, improve sustainability and reduce costs by dynamically adjusting infrastructure to demand and facilitate innovation through modern application architectures and serverless. 

By using Semeru Cloud Compiler you'll be able to do just-in-time code compiling as a process independent of the applications virtual machine. Its benefits include CPU and memory utilization optimization in the application VM and improved resiliency.

You will learn how to containize a microservice with Open Liberty InstantOn and deploy the container with Semeru Cloud Compiler enablement to a Kubernetes cluster on Azure Kubernetes Servivces (AKS).

https://openliberty.io/docs/latest/instanton.html[Open Liberty InstantOn^] provides fast startup times for MicroProfile and Jakarta EE applications. Your applications can start in milliseconds, without compromising on throughput, memory, development-production parity, or Java language features.

Semeru Cloud Compiler uses the https://eclipse.dev/openj9/docs/jitserver[JITServer^] (Just-in-Time Server) technology that is included in the https://www.eclipse.org/openj9/[Eclipse OpenJ9 JVM^]. It decouples the JIT compiler from the JVM to prevent your Java application from suffering possible negative effects due to CPU and memory consumption caused by JIT compilation in the JVM.

image::checkpoint_diagram.png[Deployment,align="center"]

Microsoft Azure offers a managed Kubernetes service called Azure Kubernetes Services (AKS). AKS simplifies the process of running Kubernetes on Azure without needing to install or maintain your Kubernetes control plane. It provides a hosted kubernetes cluster where you can deploy your microservices. You will use AKS with Azure Container Registry. Azure Container Registry is a private registry that is used to store and distribute your container images. Note, Azure Container Registry is a paid service but there is a option for a free trial which you can setup by visting https://azure.microsoft.com/en-gb/free[Try Azure for free^] and following the instructions. 


The microservice you will deploy is called `system`. The `system` microservice returns the JVM system properties of the running container. It also returns the pod’s name in the HTTP header, making replicas easy to distinguish from each other.

image::checkpoint_diagram.png[Deployment,align="center"]

// =================================================================================================
// Prerequisites
// =================================================================================================

== Additional prerequisites

You must run this guide in a Linux environment with the X86-64/AMD64 processor and the following version:

* *Ubuntu:* kernel version must be 5.9 or greater
* *RHEL:*   version must be 9.0 or greater

Before you begin, the following additional tools need to be installed on your Linux:

* *Podman:* You need containerization software for building containers. Kubernetes supports various container types, but you will need the latest available version of Podman in this guide. For installation instructions, refer to the official https://podman.io/docs/installation documentation.

* *kubectl:* You need the Kubernetes command-line tool `kubectl` to interact with your Kubernetes cluster. See the official https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl[Install and Set Up kubectl^] documentation for information about downloading and setting up `kubectl` on your platform.

* *libseccomp-dev:* You need ot intall `libseccomp-dev` to enable the instalation of `runc`. `libseccomp` is required to enable seccomp support.

+
You can install it using the following command:

+
[role=command]
```
sudo apt-get install libseccomp-dev
```

* *runc:* Runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. Find out more information and installation instructions: https://github.com/opencontainers/runc[opencontainers/runc Github repository^]

* *Azure Subscription:* To run this guide, you will need an Azure subscription. Navigate to the 
https://azure.microsoft.com/en-us/pricing/purchase-options/pay-as-you-go/[Microsoft Azure Purchase Options^] 
to create an account with your email and start a Pay-As-You-Go subscription. 

* *Azure CLI:* You will need to use the Azure Command Line Interface (CLI). See the official
https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest[Install the Azure CLI^]
documentation for information about setting up the Azure CLI for your platform. 
To verify that the Azure CLI is installed correctly, run the following command:

+
[role=command]
```
az --version
```

* *kubectl:* You need the Kubernetes command-line tool `kubectl` to interact with your Kubernetes cluster.
If you do not have `kubectl` installed already, use the Azure CLI to download and install `kubectl` with the following command:

+
[role=command]
```
az aks install-cli
```

To begin this guide, make sure that you are logged in to Azure to get access to your subscription:

[role=command]
```
az login
```

// =================================================================================================
// Getting Started
// =================================================================================================

[role=command]
include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide because it would be too long due to all setup the user will have to do.

=== Creating a resource group


A resource group is an Azure construct to manage a logical collection of resources for your cloud deployments on Azure. 
You must create a new resource group to manage the resources you need for your Kubernetes deployment.

To create a resource group, an Azure location must be specified. The metadata for your resources are stored at this specified Azure location. 
If resources are created later without specifying a location, these new resources run in the
same region that you specified for creating a resource group. 

See the list of available Azure regions for your Azure subscription:

[role=command]
```
az account list-locations -o table
```

You will see an output similar to the following:

[role="no_copy"]
----
DisplayName          Latitude    Longitude    Name
-------------------  ----------  -----------  ------------------
Central US           41.5908     -93.6208     centralus
East US              37.3719     -79.8164     eastus
East US 2            36.6681     -78.3889     eastus2
West US              37.783      -122.417     westus
North Central US     41.8819     -87.6278     northcentralus
South Central US     29.4167     -98.5        southcentralus
Canada Central       43.653      -79.383      canadacentral
Canada East          46.817      -71.217      canadaeast
UK South             50.941      -0.799       uksouth
UK West              53.427      -3.084       ukwest
West Central US      40.890      -110.234     westcentralus
West US 2            47.233      -119.852     westus2
----

The `name` column specifies the region name that you use to create your resource group.

However, AKS is not available in all regions. Make sure that the region you select is 
https://azure.microsoft.com/en-us/global-infrastructure/services/?products=kubernetes-service[compatible with AKS^].

Create a resource group using the `az group create` command. Remember to replace `[location]` with a region 
that is available for your subscription and compatible with AKS.

[role=command]
```
az group create -l [location] -n guideGroup
```

You will see an output similar to the following:

[role="no_copy"]
```
{
  "id": "/subscriptions/[subscription-id]/resourceGroups/guideGroup",
  "location": "[location]",
  "managedBy": null,
  "name": "guideGroup",
  "properties": {
    "provisioningState": "Succeeded"
  },
  "tags": null,
  "type": null
}
```

=== Creating a container registry

Your private container registry manages Docker images that you build in later steps. 
With the Azure `az acr` command, create an Azure Container Registry.
Replace `[registry-name]` with a container registry name that is unique within Azure and
contains 5-50 alphanumeric characters. You can check whether a registry name already exists by
using the `az acr check-name -n [registry-name]` command.

[role=command]
```
az acr create -g guideGroup -n [registry-name] --sku Basic --admin-enabled
```

In the `az acr create` command, the `-g` option specifies the resource group to designate to the container registry. 
You created this resource group before as `guideGroup`. The `-n` option specifies the name of the
container registry to be created, which is defined as `[registry-name]`. The `--admin-enabled` flag indicates that the admin user is enabled. 

The possible Stock Keeping Unit (SKU) values that can be passed into the `--sku` option are `Basic`, `Standard`, and `Premium`.
These different SKU options provide pricing for various levels of capacity and usage. You use a Basic SKU because it is cheaper 
and the services you deploy have low storage and throughput requirements.

You will see an output similar to the following:

[role="no_copy"]
```
{
  "adminUserEnabled": true,
  "creationDate": "2019-06-05T20:28:09.637994+00:00",
  "id": "/subscriptions/[subscription-id]/resourceGroups/guideGroup/providers/Microsoft.ContainerRegistry/registries/[registry-name]",
  "location": "[location]",
  "loginServer": "[registry-name].azurecr.io",
  "name": "[registry-name]",
  "networkRuleSet": null,
  "provisioningState": "Succeeded",
  "resourceGroup": "guideGroup",
  "sku": {
    "name": "Basic",
    "tier": "Basic"
  },
  "status": null,
  "storageAccount": null,
  "tags": {},
  "type": "Microsoft.ContainerRegistry/registries"
}
```
In the output, the value for `loginServer` is the server name for your container registry,
which is `[registry-name].azurecr.io`, with all lowercase letters.

=== Logging into the container registry

To push Podman images to your registry, you must log in to your Azure Container Registry by using the Azure CLI.

To login to the registry with Podman instead of Podman there is a few more commands required.

Firstly, login to the regsitry whilst exposing the token which you will set to the `TOKEN` variable

[role=command]
```
TOKEN=$(az acr login --name [registry-name] --expose-token --output tsv --query accessToken)
```

Next, log podman into the registry server by passing through the token variable you have set in the previous step.

[role=command]
```
podman login [registry-name.azurecr.io] --username 00000000-0000-0000-0000-000000000000 --password-stdin <<< $TOKEN
```

Once you log in, you will see the following message:

[role="no_copy"]
----
Login Succeeded
----

// =================================================================================================
// Building your InstantOn image
// =================================================================================================

== Building your InstantOn image 

To speed up your container startup time, build your container image with the Open Liberty InstantOn.

This configuration performs the application process checkpoint and stores the process data as the last layer of the application container image. In this guide, use the `afterAppStart` checkpoint option.
This phase has the potential to provide the fastest startup time when restoring the application instance. The checkpoint happens after all configured applications are reported as started.
This phase happens before opening any ports for listening to incoming requests for the applications. For more information about the checkpoint options, see the link:https://openliberty.io/docs/latest/instanton.html#beforeAppStart[Faster startup with InstantOn^]

Navigate to the `start` directory. Run the following command to build and package the `system` microservice to a war file:

[role=command]
```
mvn package
```

To containize your microservice, use the `kernel-slim-java17-openj9-ubi` Liberty container image that uses the Open Liberty basic runtime with the Semeru Runtime 17.
 
[role="code_command hotspot file=0",subs="quotes"]
----
#Create the `Containerfile`.#
`system/Containerfile`
----

// File 0
Containerfile
[source, text, linenums, role="code_column"]
----
include::finish/system/Containerfile[]
----

[role="code_command hotspot file=1",subs="quotes"]
----
#Create the `Containerfile`.#
`inventory/Containerfile`
----

// File 1
Containerfile
[source, text, linenums, role="code_column"]
----
include::finish/inventory/Containerfile[]
----

